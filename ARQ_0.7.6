                  
//////////////////////The ASCII Roguelike Quester -- Experimental project/////////////////////////////////////////////////////////////////////
//                                                                                                                                          //
//  Author: Rave Kutsuu                     Version : 0.7.6 -- Door Locks                                                                   //
//  Created: Dec 16, 2012                   Last Modified: 04 Aug, 2013                                                                     //
//                                                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//         DOCUMENTATION WILL BE INCLUDED IN FINAL DEVELOPMENT BUILD                                                                        //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <ncurses.h>

//---------grid sizes---------//
#define grid_x 30
#define grid_y 15
#define inv_x 3
#define inv_y 5

using namespace std;

//--TODO--//
//1. Health and Loot Count system (certain actions affect health, health affects gameplay, death, loot loss?, update interaction to work with this)
//2. NPCs (Fixed bosses, fighting, lootable corpses?, moving bosses)
////////////

//--Final TODO--//
//1. Load game/item maps from files
//2. Level Progression
//3. Full ending
//4. Extras
////////////

//--------running toggle---------//
bool running;
bool selection;

//---------hud variables---------//
int health;
int loot;

//--------Movement Variables--------//
int player_x,player_y,move_x,move_y;

//------------ Cell Type/Game Guide ------------//
//                                              
//--------Environment/Gamespace---------//      
/////////////////////////////////////////////   
//these cell types constitute the main     //  
//gamespace of the dungeon and provide the //   
//player with a reactive environment       //
/////////////////////////////////////////////
//
// non - nothing
// cor - corridor
// rom - room
// wa1 - wall type 1
// wa2 - wall type 2
// wa3 - wall type 3
// win - window 
// ded - deadly cell
//
//---------doors---------//
/////////////////////////////////////////////////
//These cell types provide the player          //  
//with environmental barriers that can be      //   
//interacted with, these provide a barrier to  //
//game progress in some cases, and need to be  //
//"toggled" to another doortype to pass via    //
//player interaction (items may be needed such //
//as lockpicks or keys to pass some doors)     //
/////////////////////////////////////////////////
//
// od0 - open door type 0 -main office door, no lock-
// cd0 - closed door type 0
//
// od1 - open door type 1 -main lockable door, has 1 lock-
// cd1 - closed door type 1
// ld1 - locked door type 1
//
// od2 - open door type 2 -secondary lockable door, has 2 locks-
// cd2 - closed door type 2
// ld2 - locked door type 2 
//
// ent - level entrance 
// ext - level exit
//
//---------Items(placeable)---------//
/////////////////////////////////////////////
//Placeable items are specific celltypes   //
//that create placeable loot in the dungeon//
//that can either help the player progress //
//or increase their score.                 //
/////////////////////////////////////////////
//
// key - a key, can be used to open any "ld"
// lop - lockpick, can be used to open any "lc"
//

//cell types
enum tile {ntl,cor,rom,wa1,wa2,wa3,win,od0,cd0,od1,cd1,ld1,od2,cd2,ld2,ent,ext,ded};

//item types
enum item {nit,lop,key,sta,gcn,scn,bcn,gbr,sbr,bbr};

struct tile_details 
 {
  int tile_id;
  const char* tile_char;
  int tile_colour;
  string tile_name;
  int locks;
 };
 
struct item_details
 {
  int item_id;
  const char* item_char;
  int item_colour;
  string item_name;
  int item_value;
 };
  
tile_details tile_library[] =
{
 {0," ",0, "NO TILE",0 }, //non
 {1,"-",4, "Corridor",0 }, //cor
 {2,"!",4, "Room",0 }, //rom
 {3,"#",3, "Concrete Wall",0 }, //wa1
 {4,"#",3, "Stone Wall",0 }, //wa2
 {5,"#",3, "Brick Wall",0 }, //wa3
 {6,"%",6, "Window",0},
 {7,"-",0, "Open Office Door",0 },
 {8,"=",2, "Closed Office Door",0 },
 {9,"-",0, "Open Metal Door",1 },
 {10,"=",2, "Closed Metal Door",1 },
 {11,"=",1, "Locked Metal Door",1 },
 {12,"-",0, "Open Reinforced Door",2 },
 {13,"=",2, "Closed Reinforced Door",2 },
 {14,"=",1, "Locked Reinforced Door",2},
 {15,"@",1, "Entrance",0 },
 {16,"@",2, "Exit",0 },
 {17,"!",7, "Deadly Floor",0 },
};

item_details item_library[]=
 {
  {0," ",0, "Empty    ",0}, //item_none
  {1,"!",2, "Lockpick ",1}, //item_locp
  {2,"!",2, "Door Key ",5}, //item_dkey
  {3,"!",2, "Statue   ",500},
  {4,"!",2, "Gold Coin",50},
  {5,"!",2, "Silv Coin",25},
  {6,"!",2, "Brnz Coin",10},
  {7,"!",2, "Gold Bar ",100},
  {8,"!",2, "Silv Bar ",50},
  {9,"!",2, "Brnz Bar ",25},
 };
    
//main map
tile game_grid[grid_y][grid_x] = 
{ 
    {wa1,wa1,ent,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1},
    {wa1,cor,cor,cor,cor,cor,cor,cor,cor,wa2,rom,rom,rom,rom,rom,rom,rom,rom,rom,rom,cd0,rom,rom,rom,rom,rom,rom,rom,rom,wa1},
    {wa1,cor,wa2,wa2,cd0,cd0,wa2,wa2,cor,wa2,rom,rom,rom,rom,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,rom,rom,rom,wa1},
    {wa1,cor,wa2,rom,rom,rom,rom,wa2,cor,wa2,rom,rom,rom,rom,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,rom,rom,rom,wa1},
    {wa1,cor,wa2,rom,rom,rom,rom,wa2,cor,wa2,rom,rom,rom,rom,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,rom,rom,rom,wa1},
    {wa1,cor,wa2,rom,rom,rom,rom,wa2,cor,wa2,rom,rom,rom,rom,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,rom,rom,rom,wa1},
    {wa1,cor,wa2,rom,rom,rom,rom,wa2,cor,wa2,rom,rom,rom,rom,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,rom,rom,rom,wa1},
    {wa1,cor,wa2,wa2,wa2,wa2,wa2,wa2,cor,wa2,wa2,wa2,cd0,wa2,wa2,wa2,wa2,wa2,wa2,wa2,wa2,wa2,wa2,wa2,cd0,wa2,wa2,wa2,wa2,wa1},
    {wa1,cor,cor,cor,cor,cor,cor,cor,cor,wa2,cor,cor,cor,ded,ded,ded,cor,cor,cor,cor,cor,cor,cor,cor,cor,cor,cor,cor,cor,wa1},
    {wa1,wa2,wa2,wa2,wa2,wa2,wa2,wa2,cd1,wa2,cor,wa2,wa2,wa2,wa2,wa2,wa2,wa2,wa2,wa2,wa2,cd0,wa2,wa2,wa2,cd0,wa2,wa2,wa2,wa1},
    {wa1,rom,ded,rom,rom,rom,ded,wa2,cor,wa2,cor,wa2,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,wa1},
    {wa1,rom,ded,rom,rom,rom,ded,wa2,cor,wa2,cor,wa2,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,wa1},
    {wa1,ded,ded,ded,rom,ded,ded,wa2,cor,ld1,cor,wa2,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,wa1},
    {wa1,ded,ded,rom,rom,rom,rom,rom,cor,ld1,cor,cd0,rom,rom,rom,rom,rom,rom,wa2,rom,rom,rom,rom,wa2,rom,rom,rom,rom,rom,wa1},
    {wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,wa1,ext,wa1,wa1,wa1},
};

item game_items[grid_y][grid_x] = 
{
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},  
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,bbr,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,key,nit,nit,nit,nit,nit,nit,nit,nit,nit,key,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
    {nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit,nit},
};

item inventory[inv_y][inv_x];

int wprintw_col (WINDOW* winchoice, const char *text, int color_choice) //allows ncurses window and colour selection when outputting characters
{
 wattron(winchoice,COLOR_PAIR(color_choice)); //turns on the chosen colour pair
 wprintw (winchoice, text); 
 wattroff(winchoice,COLOR_PAIR(color_choice)); //turns off the chosen colour pair
 return (0);
};             

int wprint_at (WINDOW* winchoice, const char *text, int pos_y, int pos_x)
{
 wmove (winchoice,pos_y,pos_x);
 wprintw (winchoice, text); 
 wrefresh (winchoice);
 return (0);
}

int init_screen (void)
{
 initscr();

 if (has_colors() == FALSE)
   {  
    endwin();
	  printf("Your terminal does not support color\n");
     getch();
	  return(0);
	 }
 start_color();	
 
 //---------colour pairs---------//
 init_pair(0, COLOR_BLACK, COLOR_BLACK);
 init_pair(1, COLOR_RED, COLOR_BLACK);
 init_pair(2, COLOR_GREEN, COLOR_BLACK);
 init_pair(3, COLOR_YELLOW, COLOR_BLACK);
 init_pair(4, COLOR_BLUE, COLOR_BLACK);
 init_pair(5, COLOR_MAGENTA, COLOR_BLACK);
 init_pair(6, COLOR_CYAN, COLOR_BLACK);
 init_pair(7, COLOR_WHITE, COLOR_BLACK);

 return (0);
};

int drawmap (WINDOW* winchoice)
{
 wmove (winchoice,0,0);
 	for (int y = 0; y < grid_y; y++)
	 {
	  wmove (winchoice,y,0);
	  for(int x = 0; x < grid_x; x++)
		{
       int maptile_tile;
       int maptile_colour;
       const char *maptile_char;
      
       if (game_items [y][x] !=nit)
        {
         maptile_tile = game_items [y][x];
         maptile_colour = item_library[maptile_tile].item_colour;
		   maptile_char = item_library[maptile_tile].item_char;
        }
         
       else
        { 
         maptile_tile = game_grid [y][x];
         maptile_colour = tile_library[maptile_tile].tile_colour;
		   maptile_char = tile_library[maptile_tile].tile_char;
        };
        
		 wmove (winchoice,y,x);
		 wprintw_col (winchoice, maptile_char, maptile_colour);
		}; 
	  }; 
 return (0);
};

int drop_item (WINDOW* input_win, WINDOW* inv_win, int ply_x, int ply_y)
 {
  item inv_tile;
  int invtile_colour;
  int loc_x,loc_y,scr_x,scr_y;
  string str;
  string slc_string;
  char slc_char[20];
  
  loc_x = 0;
  loc_y = 0;
  scr_x = 9;
  scr_y = 0;
  
  //IF INV IS EMPTY, DO NOT ALLOW SELECTION?
  selection = true;

  while (selection == true) 
   {
    mvwchgat (inv_win, scr_y, scr_x, 9, A_NORMAL, 0, NULL);
    wrefresh (inv_win);
    
    scr_x = loc_x*9;
    scr_y = loc_y;
    
    mvwchgat (inv_win, scr_y, scr_x, 9, A_BLINK, 1, NULL);
    wrefresh (inv_win);
    
    werase (input_win);
    wprint_at (input_win, "Select item to drop with WASD.. 'Drop' to drop the selected item, 'Exit' to cancel", 0,0);
    
    wprint_at (input_win,"ARQ:~$ ",2,0);
    
    wgetstr (input_win, slc_char);
    slc_string = slc_char;
    
    if ((slc_string == "W") || (slc_string == "w")) 
     {
      if (loc_y == 0)
       {
        loc_x = loc_x;
        loc_y = loc_y;
       }
      
      else
       {
        loc_x = loc_x;
        loc_y = loc_y-1;
       };
     }
  
    else if ((slc_string == "A") || (slc_string == "a")) 
     {
      if (loc_x == 0)
       {
        loc_x = loc_x;
        loc_y = loc_y;
       }
      
      else
       {
        loc_x = loc_x-1;
        loc_y = loc_y;
       };
     }
     
    else if ((slc_string == "S") || (slc_string == "s")) 
     {
      if (loc_y == 4)
       {
        loc_x = loc_x;
        loc_y = loc_y;
       }
      
      else
       {
        loc_x = loc_x;
        loc_y = loc_y+1;
       };
     }
  
    else if ((slc_string == "D") || (slc_string == "d")) 
     {
      if (loc_x == 2)
       {
        loc_x = loc_x;
        loc_y = loc_y;
       }
      
      else
       {
        loc_x = loc_x+1;
        loc_y = loc_y;
       };
     }
    
    else if ((slc_string == "Exit") || (slc_string == "exit") || (slc_string == "EXIT")) 
     {
      selection = false;
      return (0);
     }
     
    else if ((slc_string == "Drop") || (slc_string == "drop") || (slc_string == "DROP")) 
     {
       if (game_items[ply_y][ply_x] == nit)
        {
		  if (inventory[loc_y][loc_x] != nit)
           {
             inv_tile = inventory[loc_y][loc_x];
     
             game_items[ply_y][ply_x] = inv_tile;
             inventory[loc_y][loc_x] = nit;
          
             inv_tile = inventory[loc_y][loc_x];
          
             invtile_colour = item_library[inv_tile].item_colour;
             str = item_library[inv_tile].item_name;
           
             const char *invtile_char = str.c_str();
        
             wmove (inv_win,scr_y,scr_x);
             wprintw_col (inv_win, invtile_char, invtile_colour);
             wrefresh (inv_win);
             werase (input_win);
             wprintw (input_win, "Item dropped.");
             wgetch(input_win);
            }
            
           else
            {
		     werase (input_win);
             wprintw (input_win, "No item selected.");
             wgetch(input_win);
	       };
         }
         
         else
          {
		    werase (input_win);
            wprintw (input_win, "There's already an item here.");
            wgetch(input_win);
	       };
     }
    
    else 
     {
      werase (input_win);
      wprint_at (input_win, "Not a correct selection, try again.", 0, 0);
      wgetch (input_win);
     };
    cout << "\n " << loc_x << " " << loc_y;
   };
  return (0);
 };
 
int invproc (item itm) 
{
 for (int y = 0; y < inv_y; y++)
  {
   for(int x = 0; x < inv_x; x++)
    {
     if (inventory[y][x] == nit) //If slot is empty
      { 
	   inventory[y][x] = itm; //Place the item in empty slot
      return (0);
      };
	}; 
  };
 return(1);	
};

int itmproc (WINDOW* winchoice, item itm, int y, int x)
{
 string answer;
 char answerchar[20];
 string itm_name;
 itm = game_items[y][x];
 itm_name = item_library[itm].item_name; 
 
 werase (winchoice);
 wmove (winchoice,0,0);
 wprintw (winchoice,"There's a %s on the floor..", itm_name.c_str());
 wrefresh (winchoice);
 wgetch (winchoice); 
 wmove (winchoice,0,0);
 wprintw (winchoice,"Would you like to pick up the %s? ",itm_name.c_str());
 wgetstr (winchoice, answerchar);
 answer = (answerchar);
      
  if ((answer == "Yes") || (answer == "YES") || (answer == "yes") || (answer == "y") || (answer == "Y"))
   {
    if (invproc (itm) == (1)) //If invproc unsuccessful
     {
      werase (winchoice);
      wprint_at (winchoice,(const char *)"Inventory full..",0,0);
      wgetch (winchoice);
      return (1);
     }
    
    else
     {
      wmove (winchoice,0,0);
      werase (winchoice);
      wprintw (winchoice,"You pick up the %s..",itm_name.c_str());
      wgetch (winchoice);
      game_items[y][x] = nit; //Removes the item from the map 
      player_x = x; //Places the player where the item was
      player_y = y;
      return (0);
     };
   }
   
   else if ((answer == "No") || (answer == "NO") || (answer == "no") || (answer == "n") || (answer == "N"))
    {
     wmove (winchoice,0,0);
     werase (winchoice);
     wprintw (winchoice,"You leave the %s untouched..",itm_name.c_str());
     wgetch (winchoice);
     return (0);
    }
    
   else 
    {
     wprint_at (winchoice, "Incorrect choice, please answer yes or no.. ",0,0);
     wgetch (winchoice);
     itmproc (winchoice,itm,y,x);
    };
    
 return (0);
};

int drawinv (WINDOW* winchoice)
 {
  wmove (winchoice,0,0);
 	for (int y = 0; y < inv_y; y++)
	 {
	  wmove (winchoice,y,0);
	  for(int x = 0; x < inv_x; x++)
		{
         int inv_tile;
         int invtile_colour;
         string str;
         
         inv_tile = inventory[y][x];
         invtile_colour = item_library[inv_tile].item_colour;
	      str = item_library[inv_tile].item_name;
         
         const char *invtile_char = str.c_str();
        
         wprintw_col (winchoice, invtile_char, invtile_colour);
		}; 
	  };  
 return (0);
};

int drawplayer (WINDOW* winchoice)
{
 wmove (winchoice, player_y, player_x);
 wprintw_col (winchoice,"@",5);
 return (0);
};

int stats (WINDOW* winchoice)
{
 wmove (winchoice,1,1);
 wprintw_col (winchoice,"Health: ",4); 
 wprintw (winchoice,"%d",health);
 
 wmove (winchoice,2,0);
 wprintw_col (winchoice," Loot:   ",4); 
 wprintw (winchoice,"%d",loot);
 return (0);
}

int lock_proc (WINDOW * winchoice, int door_y, int door_x, tile doortype, int doortile, string doorname )
{
 string answer;
 char answerchar[20];
 werase (winchoice);
 wprint_at (winchoice,"How would you like to unlock the door? ",0,0);
 wprint_at (winchoice,"1. Using Door Keys, 2. Using Lock Picks ",1,0);
 wprint_at (winchoice,"Enter a choice to continue, or 'exit' to cancel ",2,0);
 wprint_at (winchoice,"lock_proc:~$  ",3,0);
 wgetstr (winchoice, answerchar);
 answer = (answerchar);
      
   if ((answer == "1") || (answer == "Key") || (answer == "Keys") || (answer == "key") || (answer == "keys") || (answer == "Door Key") || (answer == "Door Keys") || (answer == "door key") || (answer == "door keys"))
    {
     int inv_tile;
     int key_count;
     int count;
     count = 0;
     key_count = 0;
      
      for (int y = 0; y < inv_y; y++)
       {
        for(int x = 0; x < inv_x; x++)
         {
          inv_tile = inventory[y][x];
          
          if (inv_tile == (key))
           {
            key_count = (key_count+1);
           };
          
         };
       }; 
     
     if (key_count == (tile_library[doortile].locks))
      {
            
       for (int y = 0; y < inv_y; y++)
        {
         for(int x = 0; x < inv_x; x++)
          {
           inv_tile = inventory[y][x];
           
           if (inv_tile == (key))
            {
             inventory[y][x] = nit;
             count = (count+1);
            };
                 
           if (count == (tile_library[doortile].locks))
            {
             werase (winchoice);
             wmove (winchoice,0,0);
             wprintw (winchoice,(const char *)"You insert %d keys into the door and open it .. ",tile_library[doortile].locks);
             wgetch (winchoice);
       
             if (doortype == ld1) 
              {
               game_grid[door_y][door_x]=(od1);
               
               if (game_grid[door_y+1][door_x] == (ld1)) //Checking for surrounding door tiles
                {
                 game_grid[door_y+1][door_x]=(od0);
                }
          
               else if (game_grid[door_y-1][door_x] == (ld1)) 
                {
                 game_grid[door_y-1][door_x]=(od0);
                }
          
               else if (game_grid[door_y][door_x+1] == (ld1)) 
                {
                 game_grid[door_y][door_x+1]=(od0);
                }
            
               else if (game_grid[door_y][door_x-1] == (ld1)) 
                {
                 game_grid[door_y][door_x-1]=(od0);
                };
              }
                  
             else if (doortype == ld2)
              {
               game_grid[door_y][door_x]=(od2);
               
               if (game_grid[door_y+1][door_x] == (ld2)) //Checking for surrounding door tiles
                {
                 game_grid[door_y+1][door_x]=(od2);
                }
          
               else if (game_grid[door_y-1][door_x] == (ld2)) 
                {
                 game_grid[door_y-1][door_x]=(od2);
                }
          
               else if (game_grid[door_y][door_x+1] == (ld2)) 
                {
                 game_grid[door_y][door_x+1]=(od2);
                }
            
               else if (game_grid[door_y][door_x-1] == (ld2)) 
                {
                 game_grid[door_y][door_x-1]=(od2);
                };
              };
                                    
             player_x = (door_x);
             player_y = (door_y);
             return (0);
            };
            
          };
        }; 
             
      };
           
     if (key_count != (tile_library[doortile].locks))
      {
       werase (winchoice);
       wmove (winchoice,0,0);
       wprintw (winchoice,(const char *)"You need %d keys to open this door.. ",tile_library[doortile].locks);
       wgetch (winchoice);
       return (0);
      };
      
     return (0);
    }
    
   else if ((answer == "2") || (answer == "Lockpick") || (answer == "Lockpicks") || (answer == "lockpick") || (answer == "lockpicks") || (answer == "Lock Pick") || (answer == "Lock Picks") || (answer == "lock pick") || (answer == "lock picks"))
    {
     int inv_tile;
     int lockpick_count;
     int count;
     count = 0;
     lockpick_count = 0;
      
      for (int y = 0; y < inv_y; y++)
       {
        for(int x = 0; x < inv_x; x++)
         {
          inv_tile = inventory[y][x];
          
          if (inv_tile == (lop))
           {
            (lockpick_count = (lockpick_count+1));
           };
          
         };
       };
       
      if (lockpick_count >= (tile_library[doortile].locks))
       {
         
        for (int y = 0; y < inv_y; y++)
         {
          for(int x = 0; x < inv_x; x++)
           {
            inv_tile = inventory[y][x];
            
            if (inv_tile == (lop))
             {
              int chance = rand() %100+1;
              int lockno;
              
              lockno = 1;
              werase (winchoice);
              wmove (winchoice,0,0);
              wprintw (winchoice,"This door has %d lock(s).. ",tile_library[doortile].locks);
              wmove (winchoice,1,0);
              wprintw (winchoice,"You attempt to pick lock %d.. ", lockno);
              wgetch (winchoice);
              
              if (chance > 50)
               {
                werase (winchoice);
                wprint_at (winchoice,"You manage to open the lock with the lockpick.. ",0,0);
                wgetch (winchoice);
                 
                inventory[y][x] = nit;
                count = (count+1);
                chance = rand() %100+1;
                lockno = (lockno+1);
               }
              
              else if (chance <= 50)
               {
                werase (winchoice);
                wprint_at (winchoice,"Your lockpick breaks as you attempt to open the lock.. ",0,0);
                wgetch (winchoice);
                    
                inventory[y][x] = nit;
                chance = rand() %100+1;
               };
                  
             };
                 
            if (count == (tile_library[doortile].locks))
             {
              werase (winchoice);
              wprint_at (winchoice, "You manage to unlock the door.. ",0,0);
              wgetch (winchoice);
                  
              if (doortype == ld1) 
               {
                game_grid[door_y][door_x]=(od1);
               }
                  
              else if (doortype == ld2)
               {
                game_grid[door_y][door_x]=(od2);
               };
                                    
               player_x = (door_x);
               player_y = (door_y);
               return (0);
             };
                 
           };
         }; 
             
       } 
     
     else if (lockpick_count != (tile_library[doortile].locks))
      {
       werase (winchoice);
       wmove (winchoice,0,0);
       wprintw (winchoice,(const char *)"You need %d lock picks to attempt to open this door.. ",tile_library[doortile].locks);
       wgetch (winchoice);
       return (0);
      };
     
     if (count != (tile_library[doortile].locks))
      {
       werase (winchoice);
       wprint_at (winchoice, "You have run out of lockpicks..",0,0);
       wgetch (winchoice);
       return (0);
      };
     
     return (0);
    }
            
   else if ((answer == "Exit") || (answer == "EXIT") || (answer == "exit"))
    {
     werase (winchoice);
     wmove (winchoice,0,0);
     wprintw (winchoice,(const char *)"You leave the %s untouched. ",doorname.c_str());
     wgetch (winchoice);
     return (0);
    }
	    
   else
    {
     wprint_at (winchoice,(const char *)"Not a correct choice, try again.. ",0,0);
     lock_proc (winchoice,door_y,door_x,doortype,doortile,doorname);
    };
 return (0);
};

int door_proc (WINDOW * winchoice, int y, int x, tile doortype)
{
 int map_tile = game_grid[y][x];
 string door_name = tile_library[map_tile].tile_name;
 
    if ((doortype == od0) || (doortype == od1) || (doortype == od2))
     {
        wmove (winchoice,0,0);
        wprintw (winchoice,"You enter the doorway of the %s.. ",door_name.c_str());
        wgetch (winchoice);
        player_x = (x);
        player_y = (y);
   
        return (0);
     }
     
    else if ((doortype == cd0) || (doortype == cd1) || (doortype == cd2))
     {
	   string answer;
      char answerchar[20];
      wmove (winchoice,0,0);
      wprintw (winchoice,"Would you like to open the %s? ",door_name.c_str());
      wgetstr (winchoice, answerchar);
      answer = (answerchar);
      
       if ((answer == "Yes") || (answer == "YES") || (answer == "yes") || (answer == "y") || (answer == "Y"))
        {
         wmove (winchoice,0,0);
         wprintw (winchoice,"You open the %s and step into the doorway. ",door_name.c_str());
         wgetch (winchoice);
         
         if (game_grid[y][x] == (cd0)) //Checking main tile
          {
           game_grid[y][x]=(od0);
           
           if (game_grid[y+1][x] == (cd0)) //Checking for surrounding door tiles
            {
             game_grid[y+1][x]=(od0);
            }
          
           else if (game_grid[y-1][x] == (cd0)) 
            {
             game_grid[y-1][x]=(od0);
            }
          
            else if (game_grid[y][x+1] == (cd0)) 
            {
             game_grid[y][x+1]=(od0);
            }
            
            else if (game_grid[y][x-1] == (cd0)) 
            {
             game_grid[y][x-1]=(od0);
            };
          };
         
         if (game_grid[y][x] == (cd1))
          {
           game_grid[y][x]=(od1);
           
           if (game_grid[y+1][x] == (cd1)) //Checking for surrounding door tiles
            {
             game_grid[y+1][x]=(od1);
            }
          
           else if (game_grid[y-1][x] == (cd1)) 
            {
             game_grid[y-1][x]=(od1);
            }
          
            else if (game_grid[y][x+1] == (cd1)) 
            {
             game_grid[y][x+1]=(od1);
            }
            
            else if (game_grid[y][x-1] == (cd1)) 
            {
             game_grid[y][x-1]=(od1);
            };
          };
         
         if (game_grid[y][x] == (cd2))
          {
           game_grid[y][x]=(od2);
           
           if (game_grid[y+1][x] == (cd2)) //Checking for surrounding door tiles
            {
             game_grid[y+1][x]=(od2);
            }
          
           else if (game_grid[y-1][x] == (cd2)) 
            {
             game_grid[y-1][x]=(od2);
            }
          
            else if (game_grid[y][x+1] == (cd2)) 
            {
             game_grid[y][x+1]=(od2);
            }
            
            else if (game_grid[y][x-1] == (cd2)) 
            {
             game_grid[y][x-1]=(od2);
            };
          };
          
         player_x = (x);
         player_y = (y);
         return (0);
	    }
	    
	   else if ((answer == "No") || (answer == "NO") || (answer == "no") || (answer == "n") || (answer == "N"))
	    {
	     wmove (winchoice,0,0);
        wprintw (winchoice,"You leave the %s untouched. ",door_name.c_str());
        wgetch (winchoice);
        return (0);
	    }
	   
	   else
        {
         wprint_at (winchoice,"Not a yes or no answer, try again..",0,0);
         door_proc (winchoice, y, x, game_grid[y][x]);
        };
        
	   return (0);
      }
      
    else if ((doortype == ld1) || (doortype == ld2))
     {
	   string answer;
      char answerchar[20];
      werase (winchoice);
      wprint_at (winchoice,"Would you like to open the door? ",0,0);
      wgetstr (winchoice, answerchar);
      answer = (answerchar);
      
       if ((answer == "Yes") || (answer == "YES") || (answer == "yes") || (answer == "y") || (answer == "Y"))
        {
         lock_proc (winchoice, y,x,doortype,map_tile,door_name);
         return (0);
        }
   
            
       else if ((answer == "No") || (answer == "NO") || (answer == "no") || (answer == "n") || (answer == "N"))
        {
         wmove (winchoice,0,0);
         wprintw (winchoice,(const char *)"You leave the %s untouched. ",door_name.c_str());
         wgetch (winchoice);
         return (0);
        }
	    
       else
        {
         wprint_at (winchoice,(const char *)"Not a yes or no answer, try again..",0,0);
         door_proc (winchoice, y, x, game_grid[y][x]);
        };
      return (0);
     };

 return (0);
};

int moveproc (WINDOW * winchoice, int y, int x)
{
 string move_tilename = tile_library[game_grid[y][x]].tile_name;
 move_x = (x);
 move_y = (y);
 
 if (game_items[y][x] != nit)
  {
   item itm = game_items[y][x];
   itmproc (winchoice, itm, y, x);
   return (0);
  };

 if (game_grid[y][x] == ntl)
  {
   return (1);
  }
    
 else if ((game_grid[y][x] == cor) || (game_grid[y][x] == rom))
  {
   wmove (winchoice,0,0);
   wprintw (winchoice,"You walk along the %s.. ",move_tilename.c_str());
   player_x = (move_x);
   player_y = (move_y);
   wgetch (winchoice);
   return (0);  
  }
  
 else if ((game_grid[y][x] == wa1) || (game_grid[y][x] == wa2) || (game_grid[y][x] == wa3))
  {
   wmove (winchoice,0,0);
   wprintw (winchoice,"There's a %s, you cannot pass.",move_tilename.c_str());
   wgetch (winchoice);
   return (0);
  }
 
 else if (game_grid[y][x] == win) 
  {
   wprint_at (winchoice,(const char *)"There's a window here..",0,0);
   wgetch (winchoice);
   return (0);
  }
 
 else if (game_grid[y][x] == od0 || (game_grid[y][x] == od1) || (game_grid[y][x] == od2)) 
  {
   door_proc (winchoice, y, x, game_grid[y][x]);
   return (0);
  }
  
 else if (game_grid[y][x] == cd0 || (game_grid[y][x] == cd1) || (game_grid[y][x] == cd2) || (game_grid[y][x] == ld1) || (game_grid[y][x] == ld2)) 
  {
   wmove (winchoice,0,0);
   wprintw (winchoice,"There's a %s here..",move_tilename.c_str());
   wgetch (winchoice);
   door_proc (winchoice, y, x, game_grid[y][x]);
   return (0);
  }
  
 else if (game_grid[y][x] == ent) 
  {
   wprint_at (winchoice,(const char *)"The way you came in is locked..",0,0);
   wgetch (winchoice);
   return (0);
  }
 
 else if (game_grid[y][x] == ext) 
  {
   wprint_at (winchoice,(const char *)"You have reached the exit!",0,0);
   wgetch (winchoice);
   return (0);
  }
 
 else if (game_grid[y][x] == ded) 
  {
   wprint_at (winchoice,(const char *)"You have died!",0,0);
   wgetch (winchoice);
   return (0);
  };

return (0);
};

int input (WINDOW* winchoice, WINDOW* inv_win)
{
 string answer;
 char answerchar[20];
 werase (winchoice);
 wmove (winchoice,0,0); //moves the cursor to the window choice inputted into the function, +1 either side to avoid borders
 wprintw (winchoice,"ARQ:~$ "); 
 wgetstr (winchoice, answerchar);
 answer = answerchar;
 
 if (answer == "pos") 
  {
   cout << "player y :" << player_y;
   cout << "\nplayer x :" << player_x;
   return (0);
  }
  
 if (answer == "help") 
  {
   wprint_at (winchoice,(const char *)"phelp - player help",0,0);
   wprint_at (winchoice,(const char *)"ihelp - interactions",1,0);
   wprint_at (winchoice,(const char *)"info - game info",2,0);
   wgetch (winchoice);
   return (0);
  }
 
 if (answer == "phelp") 
  {
   wprint_at (winchoice,(const char *)"north - move north",0,0);
   wprint_at (winchoice,(const char *)"east- move east",1,0);
   wprint_at (winchoice,(const char *)"south - move south",2,0);
   wprint_at (winchoice,(const char *)"west - move west",3,0);
   wgetch (winchoice);
   return (0);
  }
  
  if (answer == "ihelp") 
  {
   wprint_at (winchoice,(const char *)"drop - drop item (selection)",0,0);
   wgetch (winchoice);
   return (0);
  }
  
  if (answer == "info") 
  {
	wprint_at (winchoice,(const char *)"Created by Rave Kutsuu",0,0); //Please leave this untouched as proof of origin
	wprint_at (winchoice,(const char *)"Version 0.7.1 - Linux native",1,0);  //Should be the current working, improved build.
	wprint_at (winchoice,(const char *)"ARQ Learner project/Tech demo",2,0);
	wprint_at (winchoice,(const char *)"Made using C++ and ncurses",3,0);
	wgetch (winchoice);
   return (0);
  }
  
  if ((answer == "north") || (answer == "North") || (answer == "NORTH") || (answer == "n") || (answer == "N")) 
  {
   moveproc (winchoice, player_y-1, player_x);
   return (0);
  }
  
  if ((answer == "east") || (answer == "East") || (answer == "EAST") || (answer == "e") || (answer == "E"))
  {
   moveproc (winchoice, player_y, player_x+1);
   return (0);
  }
  
  if ((answer == "south") || (answer == "South") || (answer == "SOUTH") || (answer == "s") || (answer == "S")) 
  {
   moveproc (winchoice, player_y+1, player_x);
   return (0);
  }
  
  if ((answer == "west") || (answer == "West") || (answer == "WEST") || (answer == "w") || (answer == "W"))
  {
   moveproc (winchoice, player_y, player_x-1);
   return (0);
  }
  
  if ((answer == "exit") || (answer == "Exit") || (answer == "EXIT") || (answer == "quit") || (answer == "Quit") || (answer == "QUIT"))
  {
   wprint_at (winchoice,(const char *)"Quitting.. ",0,0);
   wgetch (winchoice);
   running = (false);
   return(0);
  }
  
  if ((answer == "Drop") || (answer == "DROP") || (answer == "drop"))
  {
   drop_item (winchoice, inv_win, player_x, player_y);
   return(0);
  }
  
 else
  wprint_at (winchoice,(const char *)"unrecognised input, please input a command, or use 'help' for a list. ",0,0);
  wgetch (winchoice);
  input (winchoice, inv_win);
  return (0);

return (0);
};

int lootcount ()
{
 loot = 0;
 for (int y = 0; y < inv_y; y++)
  {
    for(int x = 0; x < inv_x; x++)
     {
      int itm =  inventory[y][x];
      int value = item_library[itm].item_value;
      loot = loot+value;
     };
   };
 return (0);
};


int main()
 { 
  srand(time(NULL));
 //test variable settings
 health = (100);
 loot = (0);
 player_x = (2); //x is up/down
 player_y = (1); //y is left/right 
 //starting up ncurses
 init_screen ();
 
 //segmenting display into game UI // +2 to positioning to allow for bordering
 WINDOW*titlewin=newwin(1,37,0,0); //Creates the stats window for content
 
 WINDOW*mainwin_rear=newwin(grid_y+2,grid_x+2,1,1); //Creates a new window called new win at 0,1 that has the dimensions of grid_x, and grid_y.
 WINDOW*mainwin_front=newwin(grid_y,grid_x,2,2); //Creates a new window called new win at 1,2 that has the dimensions of grid_x, and grid_y.
 
 WINDOW*consolewin_rear=newwin(6,grid_x*2+2,grid_y+3,2); //Creates the console window for deco
 WINDOW*consolewin_front=newwin(4,grid_x*2,grid_y+4,3); //Creates the console window for content
 WINDOW*statwin_rear=newwin(10,grid_y+2,1,grid_x+4); //Creates the stat window for deco
 WINDOW*statwin_front=newwin(8,grid_y,2,grid_x+5); //Creates the stats window for content

 WINDOW*invwin_rear=newwin(7,30,11,grid_x+4); //Creates the inventory window for deco
 WINDOW*invwin_front=newwin(5,28,12,grid_x+5); //Creates the inventory window for content
 
 keypad(consolewin_front, TRUE);
 
 running = (true);
 
 while ((running==true)) //Main game loop
  {
	wprint_at (titlewin,(const char *)"||ARQ -- ASCII Roguelike Quester||",0,3);
   
    box (mainwin_rear,0,0);
    wrefresh (mainwin_rear);
    box (consolewin_rear,0,0); //Puts borders around the finalised screen image
    box (statwin_rear,0,0);
    box (invwin_rear,0,0);
    
    //adding/adjusting screen content
    drawmap (mainwin_front); //Adds map content to the main window
    drawplayer (mainwin_front); //Adds the player(s?) to the main window
    drawinv (invwin_front);
    lootcount ();
    stats (statwin_front);  //Adds/Updates content to the statistic window

    //refreshing -- finalises screen image and updates the display
    wrefresh (titlewin);
    
    
    wrefresh (mainwin_front);
    
    wrefresh (consolewin_rear);
    wrefresh (consolewin_front);
    
    wrefresh (statwin_rear);
    wrefresh (statwin_front);
    
    wrefresh (invwin_rear);
    wrefresh (invwin_front);
 
    input (consolewin_front, invwin_front);
  };
 //End of game loop
 werase (titlewin);
 werase (mainwin_rear);
 werase (mainwin_front);
 werase (consolewin_rear);
 werase (consolewin_front);
 werase (statwin_rear);
 werase (statwin_front);
 werase (titlewin);
 endwin ();
 return (0);
};
